<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Dataset Explorer</title>
  <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='style.css') }}">

  <!-- Use Katex to render math if needed -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css" integrity="sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js" integrity="sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"
      onload="renderMathInElement(document.body);"></script>
</head>
<body>
  <div class="header">
    <h1>Dataset Explorer</h1>
    <div class="top-buttons">
      <button id="help-button" class="round-button" title="click for help">?</button>
      <button id="theme-toggle-button" class="round-button" title="toggle theme">üåô</button>
    </div>
  </div>
  
  <!-- Help text block, initially hidden -->
  <div id="help-text" style="display:none; margin: 10px 0;">
    <p>
      ‚ö†Ô∏è <strong>Under Construction:</strong> the dataset card needs to be completed.<br/><br/>

      <strong>Welcome to the Dataset Explorer!</strong><br/>
      Use the filters to narrow your dataset choices, type in the search bar to find datasets by name or summary, and sort them as needed. 
      Click on a dataset to see further details.
    </p>
  </div>
  
  <!-- Tags rendered below the help button -->
  <div id="tags-container">
    <!-- Tags will be dynamically inserted here -->
  </div>
  
  <!-- Controls row: Search bar (left) & Order menu (right) -->
  <div class="controls-row">
    <div class="search-bar">
      <input type="text" id="search-input" placeholder="Search datasets...">
    </div>
    <div class="sort-bar">
      <label for="sort-select">Sort by:</label>
      <select id="sort-select">
        <option value="name">Name (A-Z)</option>
        <option value="date_latest">Date (Latest)</option>
        <option value="date_earliest">Date (Earliest)</option>
      </select>
    </div>
  </div>
  
  <!-- Container for displaying datasets -->
  <div id="datasets-container">
    <!-- Matching datasets will be displayed here -->
  </div>

  <!-- Render markdown -->
  <script id="markdown-it" src="{{ url_for('static', filename='markdownit.js') }}"></script>
  <script id="data" type="application/json">{{ datasets | tojson }}</script>

  <script>
    // Markdown parser
    let md = new markdownit({linkify: true,});

    // Data from flask server
    const datasets = JSON.parse(document.getElementById("data").textContent);
    const tagData = JSON.parse('{{ tags | tojson | safe }}');
    let searchTerm = '';
    let selectedTags = [];
    // Global state to track expanded datasets by using dataset name as the key.
    let expandedStates = {};

    // Render datasets with markdown and LaTeX support
    function renderDatasets(list) {
      const container = document.getElementById("datasets-container");
      container.innerHTML = "";
      list.forEach(dataset => {
        const summaryHtml = md.renderInline(dataset.summary || "");
        const sizeHtml = md.renderInline(dataset.size || "");
        const dateHtml = md.renderInline(dataset.date || "N/A");

        // Only include full details if present
        let optionalDetails = "";
        if (dataset.download) {
          optionalDetails += `<div class="dataset-detail"><strong>Download Location:</strong> ${md.renderInline(dataset.download)}</div>`;
        }
        if (dataset.companion) {
          optionalDetails += `<div class="dataset-detail"><strong>Companion Paper:</strong> ${md.renderInline(dataset.companion)}</div>`;
        }
        if (dataset.notes) {
          optionalDetails += `<div class="dataset-detail"> ${md.renderInline(dataset.notes)}</div>`;
        }

        // Check the global expanded state for this dataset.
        const isExpanded = expandedStates[dataset.name];

        const elem = document.createElement("div");
        elem.className = "dataset";
        elem.innerHTML = `
          <div class="dataset-minimal">
            <div class="dataset-title">${dataset.name}</div>
            <div class="dataset-detail">${summaryHtml}</div>
            <div class="dataset-detail"><strong>Size:</strong> ${sizeHtml}</div>
            <div class="dataset-detail"><strong>Date Created:</strong> ${dateHtml}</div>
          </div>
          <div class="dataset-full" style="display: ${isExpanded ? 'block' : 'none'};">
            ${optionalDetails}
            <div class="dataset-detail"><strong>Tags:</strong> ${renderDatasetTags(dataset.tags)}</div>
          </div>
        `;
        // Toggle details on click and update the global expanded state.
        elem.addEventListener("click", () => {
          const details = elem.querySelector(".dataset-full");
          if(expandedStates[dataset.name]) {
            expandedStates[dataset.name] = false;
            details.style.display = "none";
          } else {
            expandedStates[dataset.name] = true;
            details.style.display = "block";
          }
        });
        container.appendChild(elem);

        // Add hyperlink logic so links don't trigger the parent click event.
        const links = elem.querySelectorAll("a");
        links.forEach(link => {
          link.setAttribute("target", "_blank");
          link.setAttribute("rel", "noopener noreferrer");
          link.setAttribute("onclick", "event.stopPropagation()");
        });
      });
    }

    // Filter datasets based on search term and selected tags.
    const updateView = () => {
      const filtered = datasets.filter(dataset => {
        const matchesSearch = !searchTerm ||
          (dataset.name && dataset.name.toLowerCase().includes(searchTerm.toLowerCase())) ||
          (dataset.summary && dataset.summary.toLowerCase().includes(searchTerm.toLowerCase())) ||
          (dataset.notes && dataset.notes.toLowerCase().includes(searchTerm.toLowerCase()));
        const matchesTags = selectedTags.length === 0 ||
          (Array.isArray(dataset.tags) && selectedTags.every(tag => dataset.tags.includes(tag)));
        return matchesSearch && matchesTags;
      });
      renderDatasets(filtered);
    };

    // Sort datasets
    function updateOrder() {
      const sortOption = document.getElementById("sort-select").value;
      datasets.sort((a, b) => {
        if (sortOption === "name") return a.name.localeCompare(b.name);
        if (sortOption === "date_latest") return new Date(b.date) - new Date(a.date);
        if (sortOption === "date_earliest") return new Date(a.date) - new Date(b.date);
      });
      updateView();
    }

    // Render and handle tag buttons with tooltips.
    function renderTags() {
      const container = document.getElementById("tags-container");
      container.innerHTML = "";
      // iterate over the array to preserve order.
      tagData.forEach(groupObj => {
        const groupContainer = document.createElement("div");
        groupContainer.className = "tag-group-line";
        const header = document.createElement("span");
        header.className = "tag-group-header";
        header.textContent = `${groupObj.group}: `;
        groupContainer.appendChild(header);
        // iterate over tags within the group.
        Object.keys(groupObj.tags).forEach(tag => {
          const tagElem = document.createElement("span");
          tagElem.className = "tag";
          tagElem.textContent = tag;
          tagElem.setAttribute("data-tooltip", groupObj.tags[tag]);
          tagElem.style.cursor = "pointer";
          tagElem.addEventListener("click", e => {
            e.stopPropagation();
            tagElem.classList.toggle("selected");
            const tagText = tagElem.textContent;
            selectedTags = tagElem.classList.contains("selected")
              ? [...selectedTags, tagText]
              : selectedTags.filter(t => t !== tagText);
            updateView();
          });
          groupContainer.appendChild(tagElem);
          groupContainer.appendChild(document.createTextNode(" "));
        });
        container.appendChild(groupContainer);
      });
    }

    // Render tags for a dataset's tag list.
    function renderDatasetTags(tags) {
      if (!tags) return "";
      return tags.map(tag => {
        let tooltip = "";
        for (let group in tagData) {
          if (tagData[group].tags && tagData[group].tags[tag]) {
            tooltip = tagData[group].tags[tag];
            break;
          }
        }
        return `<span class="tag" data-tooltip="${tooltip}">${tag}</span>`;
      }).join(" ");
    }

    // Event listeners for search and sorting.
    document.getElementById("search-input").addEventListener("input", e => {
      searchTerm = e.target.value;
      updateView();
    });
    document.getElementById("sort-select").addEventListener("change", updateOrder);

    // Help button toggles the display of help text.
    document.getElementById("help-button").addEventListener("click", () => {
      const helpText = document.getElementById("help-text");
      helpText.style.display = helpText.style.display === "none" ? "block" : "none";
    });

    // Theme toggle button: toggles dark mode and updates its icon.
    document.getElementById("theme-toggle-button").addEventListener("click", () => {
      document.body.classList.toggle("dark-mode");
      const button = document.getElementById("theme-toggle-button");
      if(document.body.classList.contains("dark-mode")){
        button.textContent = "‚òÄÔ∏è";
      } else {
        button.textContent = "üåô";
      }
    });

    // Initialization
    renderTags();
    updateOrder();
    updateView();

    // Add hovering logic over tags.
    document.querySelectorAll('.tag').forEach(tag => {
      let tooltipDiv;
      let hoverTimer; // Timer for the delay

      tag.addEventListener('mouseenter', () => {
        const text = tag.getAttribute('data-tooltip');
        if (!text) return;

        // Start the timer for 500ms delay
        hoverTimer = setTimeout(() => {
          tooltipDiv = document.createElement('div');
          tooltipDiv.className = 'custom-tooltip';
          tooltipDiv.innerText = text;
          document.body.appendChild(tooltipDiv);

          // Position the tooltip.
          const rect = tag.getBoundingClientRect();
          const tooltipRect = tooltipDiv.getBoundingClientRect();

          let top = rect.bottom + window.scrollY + 5;
          let left = rect.left + window.scrollX + (rect.width - tooltipRect.width) / 2;

          if (left + tooltipRect.width > window.innerWidth) {
            left = window.innerWidth - tooltipRect.width - 5;
          }
          if (left < 0) {
            left = 5;
          }
          if (top + tooltipRect.height > window.innerHeight + window.scrollY) {
            top = rect.top + window.scrollY - tooltipRect.height - 5;
          }

          tooltipDiv.style.top = `${top}px`;
          tooltipDiv.style.left = `${left}px`;
        }, 500);
      });

      tag.addEventListener('mouseleave', () => {
        clearTimeout(hoverTimer);
        if (tooltipDiv) {
          tooltipDiv.remove();
          tooltipDiv = null;
        }
      });
    });

  </script>
</body>
</html>
