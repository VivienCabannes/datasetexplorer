<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Dataset Explorer</title>
  <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
  <div class="header">
    <h1>Dataset Explorer</h1>
    <div class="top-buttons">
      <button id="help-button" class="round-button" title="click for help">?</button>
      <button id="theme-toggle-button" class="round-button" title="toggle theme">🌙</button>
    </div>
  </div>
  
  <!-- Help text block, initially hidden -->
  <div id="help-text" style="display:none; margin: 10px 0;">
    <p>
      Welcome to the Dataset Explorer! Use the filters to narrow your dataset choices, type in the search bar to find datasets by name, summary or notes, and sort them as needed. Click on a dataset to see further details.
    </p>
  </div>
  
  <!-- Tags rendered below the help button -->
  <div id="tags-container">
    <!-- Tags will be dynamically inserted here -->
  </div>
  
  <!-- Controls row: Search bar (left) & Order menu (right) -->
  <div class="controls-row">
    <div class="search-bar">
      <input type="text" id="search-input" placeholder="Search datasets...">
    </div>
    <div class="sort-bar">
      <label for="sort-select">Sort by:</label>
      <select id="sort-select">
        <option value="name">Name (A-Z)</option>
        <option value="date_latest">Date (Latest)</option>
        <option value="date_earliest">Date (Earliest)</option>
      </select>
    </div>
  </div>
  
  <!-- Container for displaying datasets -->
  <div id="datasets-container">
    <!-- Matching datasets will be displayed here -->
  </div>


  <!-- Render math and markdown properly -->
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$']],
      },
      svg: {
        fontCache: 'global'
      }
    };
  </script>
  <script id="Mathjax-script" src="{{ url_for('static', filename='mathjax.js') }}"></script>
  <script id="markdown-it" src="{{ url_for('static', filename='markdownit.js') }}"></script>
  <script id="data" type="application/json">{{ datasets | tojson }}</script>

  <script>
    // Renderer placeholder
    let md = new markdownit({
      html: false,
      linkify: false,
      typographer: false,
      breaks: true,
    });

    // Data from flask server
    console.log("Data from Flask server: ", document.getElementById("data").textContent);
    const datasets = JSON.parse(document.getElementById("data").textContent);
    const tagData = JSON.parse('{{ tags | tojson | safe }}');
    let searchTerm = '';
    let selectedTags = [];

    // Render datasets with markdown and LaTeX support
    function renderDatasets(list) {
      const container = document.getElementById("datasets-container");
      container.innerHTML = "";
      list.forEach(dataset => {
        // Use markdown-it to render fields that might include markdown/LaTeX
        const summaryHtml = md.render(dataset.summary || "");
        // const summaryHtml = dataset.summary || "";
        const sizeHtml = md.render(dataset.size || "");
        const dateHtml = md.render(dataset.date || "N/A");
        const notesHtml = md.render(dataset.notes || "");
        const downloadHtml = md.render(dataset.download || "");

        const elem = document.createElement("div");
        elem.className = "dataset";
        elem.innerHTML = `
          <div class="dataset-minimal">
            <div class="dataset-title">${dataset.name}</div>
            <div class="dataset-detail">${summaryHtml}</div>
            <div class="dataset-detail"><strong>Size:</strong> ${sizeHtml}</div>
            <div class="dataset-detail"><strong>Date Created:</strong> ${dateHtml}</div>
          </div>
          <div class="dataset-full" style="display: none;">
            <div class="dataset-detail"><strong>Download Location:</strong> ${downloadHtml}</div>
            <div class="dataset-detail"><strong>Companion Paper:</strong> ${
              dataset.companion === "Not available"
                ? "Not available"
                : `<a href="${dataset.companion}" target="_blank">${dataset.companion}</a>`
            }</div>
            <div class="dataset-detail">${notesHtml}</div>
            <div class="dataset-detail"><strong>Tags:</strong> ${renderDatasetTags(dataset.tags)}</div>
          </div>
        `;
        // Toggle details on click.
        elem.addEventListener("click", () => {
          const details = elem.querySelector(".dataset-full");
          details.style.display = details.style.display === "block" ? "none" : "block";
        });
        container.appendChild(elem);

        // Add hyperlink logic
        const links = elem.querySelectorAll("a");
        links.forEach(link => {
          link.setAttribute("target", "_blank");
          link.setAttribute("rel", "noopener noreferrer");
          link.setAttribute("onclick", "event.stopPropagation()");
        });
      });

      // trigger MathJax to process any LaTeX expressions
      if (window.MathJax && MathJax.typesetPromise) {
        MathJax.typesetPromise();
      }
    }

    // Filter datasets based on search term and selected tags.
    const updateView = () => {
      const filtered = datasets.filter(dataset => {
        const matchesSearch = !searchTerm ||
          (dataset.name && dataset.name.toLowerCase().includes(searchTerm.toLowerCase())) ||
          (dataset.summary && dataset.summary.toLowerCase().includes(searchTerm.toLowerCase())) ||
          (dataset.notes && dataset.notes.toLowerCase().includes(searchTerm.toLowerCase()));
        const matchesTags = selectedTags.length === 0 ||
          (Array.isArray(dataset.tags) && selectedTags.every(tag => dataset.tags.includes(tag)));
        return matchesSearch && matchesTags;
      });
      renderDatasets(filtered);
      console.log("Filtered datasets: ", filtered);
    };

    // Sort datasets
    function updateOrder() {
      const sortOption = document.getElementById("sort-select").value;
      datasets.sort((a, b) => {
        if (sortOption === "name") return a.name.localeCompare(b.name);
        if (sortOption === "date_latest") return new Date(b.date) - new Date(a.date);
        if (sortOption === "date_earliest") return new Date(a.date) - new Date(b.date);
      });
      updateView();
    }

    // Render and handle tag buttons with tooltips.
    function renderTags() {
      const container = document.getElementById("tags-container");
      container.innerHTML = "";
      // iterate over the array to preserve order.
      tagData.forEach(groupObj => {
        const groupContainer = document.createElement("div");
        groupContainer.className = "tag-group-line";
        const header = document.createElement("span");
        header.className = "tag-group-header";
        header.textContent = `${groupObj.group}: `;
        groupContainer.appendChild(header);
        // iterate over tags within the group.
        Object.keys(groupObj.tags).forEach(tag => {
          const tagElem = document.createElement("span");
          tagElem.className = "tag";
          tagElem.textContent = tag;
          tagElem.setAttribute("data-tooltip", groupObj.tags[tag]);
          tagElem.style.cursor = "pointer";
          tagElem.addEventListener("click", e => {
            e.stopPropagation();
            tagElem.classList.toggle("selected");
            const tagText = tagElem.textContent;
            selectedTags = tagElem.classList.contains("selected")
              ? [...selectedTags, tagText]
              : selectedTags.filter(t => t !== tagText);
            updateView();
          });
          groupContainer.appendChild(tagElem);
          groupContainer.appendChild(document.createTextNode(" "));
        });
        container.appendChild(groupContainer);
      });
    }

    // Render tags for a dataset's tag list.
    function renderDatasetTags(tags) {
      if (!tags) return "";
      return tags.map(tag => {
        let tooltip = "";
        for (let group in tagData) {
          if (tagData[group][tag]) {
            tooltip = tagData[group][tag];
            break;
          }
        }
        return `<span class="tag" data-tooltip="${tooltip}">${tag}</span>`;
      }).join(" ");
    }

    // Event listeners for search and sorting.
    document.getElementById("search-input").addEventListener("input", e => {
      searchTerm = e.target.value;
      updateView();
    });
    document.getElementById("sort-select").addEventListener("change", updateOrder);

    // help button toggles the display of help text.
    document.getElementById("help-button").addEventListener("click", () => {
      const helpText = document.getElementById("help-text");
      helpText.style.display = helpText.style.display === "none" ? "block" : "none";
    });

    // theme toggle button: toggles dark mode and updates its icon.
    document.getElementById("theme-toggle-button").addEventListener("click", () => {
      document.body.classList.toggle("dark-mode");
      const button = document.getElementById("theme-toggle-button");
      if(document.body.classList.contains("dark-mode")){
        button.textContent = "☀️";
      } else {
        button.textContent = "🌙";
      }
    });

    // Initialiation
    updateOrder();
    updateView();
    renderTags();

    // Add hovering logic over tags
    document.querySelectorAll('.tag').forEach(tag => {
      let tooltipDiv;
      let hoverTimer; // Timer for the delay

      tag.addEventListener('mouseenter', () => {
        const text = tag.getAttribute('data-tooltip');
        if (!text) return;

        // Start the timer for 1 second delay
        hoverTimer = setTimeout(() => {
          tooltipDiv = document.createElement('div');
          tooltipDiv.className = 'custom-tooltip';
          tooltipDiv.innerText = text;
          document.body.appendChild(tooltipDiv);

          // Position the tooltip
          const rect = tag.getBoundingClientRect();
          const tooltipRect = tooltipDiv.getBoundingClientRect();

          let top = rect.bottom + window.scrollY + 5;
          let left = rect.left + window.scrollX + (rect.width - tooltipRect.width) / 2;

          if (left + tooltipRect.width > window.innerWidth) {
            left = window.innerWidth - tooltipRect.width - 5;
          }
          if (left < 0) {
            left = 5;
          }
          if (top + tooltipRect.height > window.innerHeight + window.scrollY) {
            top = rect.top + window.scrollY - tooltipRect.height - 5;
          }

          tooltipDiv.style.top = `${top}px`;
          tooltipDiv.style.left = `${left}px`;
        }, 500); // 1 second delay
      });

      tag.addEventListener('mouseleave', () => {
        // Clear the timer if the user leaves early
        clearTimeout(hoverTimer);
        if (tooltipDiv) {
          tooltipDiv.remove();
          tooltipDiv = null;
        }
      });
    });

  </script>
</body>
</html>
