<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Dataset Explorer</title>
  <!-- Link to external CSS file -->
  <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
  <h1>Dataset Explorer</h1>
  <div class="search-bar">
    <input type="text" id="search-input" placeholder="Search datasets...">
  </div>
  <div class="tags" id="tags-container">
    <!-- Tags will be dynamically inserted here -->
  </div>
  <div class="sort-bar">
    <label for="sort-select">Sort by:</label>
    <select id="sort-select">
      <option value="name">Name (A-Z)</option>
      <option value="date_latest">Date (Latest)</option>
      <option value="date_earliest">Date (Earliest)</option>
    </select>
  </div>
  <div id="datasets-container">
    <!-- Matching datasets will be displayed here -->
  </div>

  <script>
    // Retrieve dataset and tag specifications passed from Flask via Jinja2.
    let datasets = JSON.parse('{{ datasets | tojson | safe }}');
    let tagData = JSON.parse('{{ tags | tojson | safe }}');
  
    // Render the tags grouped by type on a single line.
    function renderTags() {
      const tagsContainer = document.getElementById("tags-container");
      tagsContainer.innerHTML = "";
  
      // Iterate over each tag group (e.g., "Data Source Tags", etc.)
      Object.keys(tagData).forEach(group => {
        // Create a container for the entire group line.
        const groupContainer = document.createElement("div");
        groupContainer.classList.add("tag-group-line");
  
        // Create a header for the tag type with a colon.
        const groupHeader = document.createElement("span");
        groupHeader.classList.add("tag-group-header");
        groupHeader.textContent = group + ": ";
        groupContainer.appendChild(groupHeader);
  
        // Iterate over tags within the group.
        Object.keys(tagData[group]).forEach((tag, idx, arr) => {
          // Create the tag element.
          const tagElem = document.createElement("span");
          tagElem.classList.add("tag");
          tagElem.textContent = tag;
          tagElem.style.cursor = "pointer";
  
          // Create tooltip element.
          const tooltipText = document.createElement("span");
          tooltipText.classList.add("tooltiptext");
          tooltipText.textContent = tagData[group][tag];
          // Disable pointer events on tooltip text.
          tooltipText.style.pointerEvents = "none";
  
          // Wrap the tag element in a tooltip container.
          const tooltipContainer = document.createElement("span");
          tooltipContainer.classList.add("tooltip");
          tooltipContainer.appendChild(tagElem);
          tooltipContainer.appendChild(tooltipText);
  
          // Attach the click event to the entire tooltip container.
          tooltipContainer.addEventListener("click", () => {
            tagElem.classList.toggle("selected");
            filterDatasets();
          });
  
          // Append the tooltip container to the group container.
          groupContainer.appendChild(tooltipContainer);
  
          // Append a space after each tag except the last one.
          if (idx < arr.length - 1) {
            groupContainer.appendChild(document.createTextNode(" "));
          }
        });
        // Append the complete group container to the tags container.
        tagsContainer.appendChild(groupContainer);
      });
    }
  
    // Retrieve the currently selected tags.
    function getSelectedTags() {
      return Array.from(document.getElementsByClassName("tag"))
        .filter(tagElem => tagElem.classList.contains("selected"))
        .map(tagElem => tagElem.textContent.toLowerCase());
    }
  
    // Render tags for a dataset with tooltips.
    function renderDatasetTags(tags) {
      if (!tags) return "";
      return tags.map(tag => {
        let tooltip = "";
        // Search for the tag in all groups using case-insensitive matching.
        for (let group in tagData) {
          for (let key in tagData[group]) {
            if (key.toLowerCase() === tag.toLowerCase()) {
              tooltip = tagData[group][key];
              break;
            }
          }
          if (tooltip) break;
        }
        return `<span class="tooltip dataset-tag">${tag}
                  <span class="tooltiptext" style="pointer-events: none;">${tooltip}</span>
                </span>`;
      }).join(" ");
    }
  
    // Filter and render datasets based on search input, selected tags, and sort order.
    function filterDatasets() {
      const searchTerm = document.getElementById("search-input").value.toLowerCase();
      const selectedTags = getSelectedTags();
      console.log("Selected tags:", selectedTags);  // Debug: log selected tags
  
      const sortValue = document.getElementById("sort-select").value;
      const datasetsContainer = document.getElementById("datasets-container");
      datasetsContainer.innerHTML = "";
  
      // Filter datasets by checking search term and tag match.
      let filtered = datasets.filter(ds => {
        console.log("Dataset:", ds.name, "Tags:", ds.tags);  // Debug: log dataset tags
  
        // Check if the dataset matches the search term.
        const matchesSearch =
          ds.name.toLowerCase().includes(searchTerm) ||
          ds.summary.toLowerCase().includes(searchTerm) ||
          ds.notes.toLowerCase().includes(searchTerm);
  
        // Check if the dataset matches all selected tags.
        const matchesTags = selectedTags.length === 0 || selectedTags.every(tag => {
          // Ensure ds.tags is an array and perform case-insensitive matching.
          return Array.isArray(ds.tags) && ds.tags.some(t => t.toLowerCase() === tag);
        });
  
        return matchesSearch && matchesTags;
      });
      
      console.log("Filtered datasets:", filtered);  // Debug: log filtered results
  
      // Sort datasets based on the selected sort option.
      if (sortValue === "name") {
        filtered.sort((a, b) => a.name.localeCompare(b.name));
      } else if (sortValue === "date_latest") {
        filtered.sort((a, b) => new Date(b.date) - new Date(a.date));
      } else if (sortValue === "date_earliest") {
        filtered.sort((a, b) => new Date(a.date) - new Date(b.date));
      }
  
      // Render each filtered dataset.
      filtered.forEach(ds => {
        const dsElem = document.createElement("div");
        dsElem.classList.add("dataset");
  
        dsElem.innerHTML = `
          <div class="dataset-minimal">
            <div class="dataset-title">${ds.name}</div>
            <div class="dataset-detail"><strong>Summary:</strong> ${ds.summary}</div>
            <div class="dataset-detail"><strong>Size:</strong> ${ds.size}</div>
            <div class="dataset-detail"><strong>Date Created:</strong> ${ds.date || "N/A"}</div>
          </div>
          <div class="dataset-full">
            <div class="dataset-detail"><strong>Download Location:</strong> <a href="${ds.download}" target="_blank">${ds.download}</a></div>
            <div class="dataset-detail"><strong>Notes:</strong> ${ds.notes}</div>
            <div class="dataset-detail"><strong>Companion Paper:</strong> ${
              ds.companion === "Not available" 
                ? "Not available" 
                : `<a href="${ds.companion}" target="_blank">${ds.companion}</a>`
            }</div>
            <div class="dataset-detail"><strong>Tags:</strong> ${renderDatasetTags(ds.tags)}</div>
          </div>
        `;
        dsElem.addEventListener("click", function() {
          const details = dsElem.querySelector(".dataset-full");
          details.style.display = (details.style.display === "block") ? "none" : "block";
        });
        datasetsContainer.appendChild(dsElem);
      });
    }
  
    // Event listeners for search input and sort selection.
    document.getElementById("search-input").addEventListener("input", filterDatasets);
    document.getElementById("sort-select").addEventListener("change", filterDatasets);
  
    // Initial render.
    renderTags();
    filterDatasets();
  </script>
</body>
</html>
